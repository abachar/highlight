grammar Json;

//
// PARSER RULES
//
parse
    : root

root
    : object
	| array
	;

object
	: LBRACE (element (COMMA element)*)? RBRACE
	;

element
	: name COLON value
	;

array
	: LBRACKET value (COMMA value)* RBRACKET
	;

name
@after { addFragment(Type.NAME, $start); }
    : STRING
;

value
	: object
 	| array
  	| STRING   { addFragment(Type.STRING, $start); }
	| INTEGER  { addFragment(Type.NUMBER, $start); }
	| DOUBLE   { addFragment(Type.NUMBER, $start); }
	| literal
	;

literal
@after { addFragment(Type.KEYWORD, $start); }
	: TRUE
	| FALSE
	| NULL
    ;

//
// LEXER RULES
//
COLON   : ':';
COMMA   : ',';
LBRACE  : '{';
RBRACE  : '}';
LBRACKET: '[';
RBRACKET: ']';
TRUE    :  'true';
FALSE   : 'false';
NULL    : 'null';
WS      : (' ' | '\r' | '\t' | '\u000C' | '\n' ) -> channel(HIDDEN);
STRING  : '"' STRING_CHAR* '"';
INTEGER : INT;
DOUBLE  : INT (FRAC EXP? | EXP);

// Fragment
fragment DOT         : '.';
fragment DIGIT       : '0' .. '9';
fragment HEX_DIGIT   : ('0' .. '9' | 'A' .. 'F' | 'a' .. 'f');
fragment UNICODE_CHAR: ~('"'| '\\');
fragment STRING_CHAR :  UNICODE_CHAR | ESC_SEQ;
fragment ESC_SEQ     : '\\' ('\"' | '\\' | '/' | 'b' | 'f' | 'n' | 'r' | 't' | 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT);
fragment INT         : '-'? ('0' | '1'..'9' DIGIT*);
fragment FRAC        : DOT DIGIT+;
fragment EXP         : ('e' | 'E') ('+' | '-')? DIGIT+;

