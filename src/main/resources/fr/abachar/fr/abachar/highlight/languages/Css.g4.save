grammar Css;

tokens {
    STRING
}

@members {
    private List<Fragment> fragments = new ArrayList<Fragment>();
    private void addFragment(Type type, Token start) {
        fragments.add(new Fragment(type, start.getStartIndex(), start.getStopIndex()));
    }
    public List<Fragment> getFragments() {
        return fragments;
    }
}

//
// PARSER RULES
//
parse:
    BOM?
    at_charset? ( CDO | CDC | WS | comment )*
    ( at_import ( CDO | CDC | WS | comment )* )*
    ( at_namespace ( CDO | CDC | WS | comment )* )*
    ( ( at_media | at_page | at_keyframes | at_legacy_supprot | at_rule | ruleset ) ( CDO | CDC | WS | comment )* )*;

at_charset:
    CHARSET STRING SEMICOLON;

at_import:
    IMPORT sep ( STRING | URL_FUNC ) ( sep media_query_list )? skip? SEMICOLON;

at_namespace:
    NAMESPACE ( sep IDENT )? sep ( STRING | URL_FUNC ) skip? SEMICOLON;

at_media:
    MEDIA ( sep media_query_list )? skip? LBRACE (skip? ruleset)* skip? RBRACE;

media_query_list:
    media_query ( skip? COMMA skip? media_query )*;

media_query:
    ( ( ONLY | NOT ) sep )? media_type ( sep AND sep media_expression )*
    | media_expression ( skip? AND sep media_expression )*;

media_type:
    IDENT;

media_expression:
    LPAREN skip? media_feature ( skip? COLON skip? terms )* skip? RPAREN;

media_feature:
    IDENT;

at_page:
    PAGE pseudo_page? skip? LBRACE ( skip? ( declaration | at_legacy_supprot ) )* skip? RBRACE;

pseudo_page:
    COLON IDENT;

at_legacy_supprot:
	LEGACY_SUPPORT ( sep IDENT ( skip? COMMA skip? IDENT )* )? skip? LBRACE (skip? ruleset )* skip? RBRACE;

at_keyframes:
	KEYFRAMES sep IDENT skip? LBRACE ( skip? keyframes_block )* skip? RBRACE;

keyframes_block:
	keyframe_selector skip? LBRACE ( skip? declaration )* skip? RBRACE;

keyframe_selector:
	( IDENT | PERCENTAGE ) ( skip? COMMA skip? ( IDENT | PERCENTAGE ) )*;

at_rule:
	at_keyword sep ~( LBRACE | SEMICOLON )* SEMICOLON
	| at_keyword skip? ~( LBRACE | SEMICOLON )* block;

at_keyword
@after { addFragment(Type.KEYWORD, $start); }
	: ATKEYWORD
	;

ruleset:
    selectors_group skip? LBRACE ( skip? declaration )* skip? RBRACE;

selectors_group:
    selector ( skip? COMMA skip? selector )*;

selector
@after { addFragment(Type.NAME, $start); }
    :selector_sequence ( combinator selector_sequence )*;

selector_sequence:
    ( type_selector | universal_selector ) ( hash_selector |  class_selector | attrib_selector | pseudo_selector | negation_selector )*
    | ( hash_selector | class_selector | attrib_selector | pseudo_selector | negation_selector )+;

type_selector:
    namespace_prefix? element_selector;

element_selector:
    IDENT;

universal_selector:
    namespace_prefix? ASTERISK;

hash_selector:
    HASH;

class_selector:
    DOT IDENT;

attrib_selector:
    LBRACKET skip? attrib ( skip? match_operator skip? ( IDENT | STRING ) )? skip? RBRACKET;

attrib:
	namespace_prefix? IDENT;

namespace_prefix:
    ( IDENT | ASTERISK )? VBAR;

pseudo_selector:
    COLON COLON? ( IDENT | functional_pseudo_selector );

functional_pseudo_selector:
    FUNCTION skip? expression skip? RPAREN;

expression:
	( PLUS | MINUS | DIMENSION | NUMBER | STRING | IDENT ) ( sep ( PLUS | MINUS | DIMENSION | NUMBER | STRING | IDENT ) )*;

negation_selector:
    COLON NOT_FUNC skip? negation_arg skip? RPAREN;

negation_arg:
    type_selector | universal_selector | hash_selector | class_selector | attrib_selector |  pseudo_selector;

match_operator:
    MATCH;

combinator:
    sep | skip? ( PLUS | GREATER | TILDE ) skip?;

declaration:
    property skip? COLON skip? terms ( skip? prio )? skip? SEMICOLON;

property:
    IDENT;

terms:
    term ( ( sep | ( skip? term_separator skip? ) ) term )*;

term_separator:
	SLASH | COMMA | MATCH
	| ASTERISK | PLUS | MINUS | DOT | COLON
	| LESS | GREATER | BACKSLASH | VBAR | TILDE | DELIM;

term:
    PERCENTAGE | DIMENSION | NUMBER
    | STRING | IDENT | URL_FUNC | UNICODE_RANGE
    | hexcolor
    | MS_EXPR_FUNC | function
    | LPAREN skip? terms* skip? RPAREN
    | LBRACKET skip? terms* skip? RBRACKET;

function:
    FUNCTION skip? terms skip? RPAREN;

hexcolor:
	HASH;

prio:
    PRIO;

block:
    LBRACE ( skip? ( block | sep | ~( LBRACE | WS )+ ) )* skip? RBRACE;

sep:
	comment? WS skip?;

skip:
	( WS | comment )+;

comment
@after { addFragment(Type.COMMENT, $start); }
    : COMMENT
;

//
// LEXER RULES
//
BOM:            '\uFEFF';
IDENT:          Ident;
HASH:           '#' Name;
CHARSET:        '@charset ';
IMPORT:         '@' I M P O R T;
NAMESPACE:      '@' N A M E S P A C E;
MEDIA:          '@' M E D I A;
PAGE:           '@' P A G E;
KEYFRAMES:      '@' K E Y F R A M E S;
LEGACY_SUPPORT: '@-' W L I T E '-' L E G A C Y '-' S U P P O R T;
ATKEYWORD:      '@' Ident;
MS_EXPR_FUNC:   E X P R E S S I O N Group;
NOT_FUNC:       N O T '(';
AND:            A N D;
NOT:            N O T;
ONLY:           O N L Y;
FUNCTION:       Ident '(';
PRIO:           '!' Ident;
STRING:         String;
NUMBER:         Num;
PERCENTAGE:     Num '%';
DIMENSION:      Num Ident;
URL_FUNC:       U R L '(' WS* ( String | Url )? WS* ')';
UNICODE_RANGE:  U '+' Hex Hex? Hex? Hex? Hex? Hex? ( '-' Hex Hex? Hex? Hex? Hex? Hex? )?;
CDO:            '<!--';
CDC:            '-->';
LPAREN:         '(';
RPAREN:         ')';
ASTERISK:       '*';
PLUS:           '+';
COMMA:          ',';
MINUS:          '-';
DOT:            '.';
SLASH:          '/';
COLON:          ':';
SEMICOLON:      ';';
LESS:           '<';
GREATER:        '>';
LBRACKET:       '[';
BACKSLASH:      '\\';
RBRACKET:       ']';
LBRACE:         '{';
VBAR:           '|';
RBRACE:         '}';
TILDE:          '~';
MATCH:          [!#$%&*+./:=?@^|~-]? '=';
WS:             [ \t\r\n\f]+;
COMMENT:        '/*' .*? '*/';
DELIM:          .;

fragment Hex: [0-9a-fA-F];
fragment NonAscii: [\u0238-\uFFFF];
fragment Unicode: '\\' Hex Hex? Hex? Hex? Hex? Hex? ( '\r\n' | [ \t\r\n\f] )?;
fragment Escape: Unicode | '\\' ~[\n\r\f0-9a-fA-F];
fragment NmStart: '-'? ( [_a-zA-Z] | NonAscii | Escape );
fragment NmChar: ( [_a-zA-Z0-9-] | NonAscii | Escape );
fragment Ident: NmStart NmChar*;
fragment Name: NmChar+;
fragment Num: [+-]? ( [0-9]+ | [0-9]* '.' [0-9]+ );
fragment String: '"' ( ~[\n\r\f\\"] | '\\' ( '\r\n' | [\r\n\f] ) | Escape )* '"' | '\'' ( ~[\n\r\f\\'] | '\\' ( '\r\n' | [\r\n\f] ) | Escape )* '\'';
fragment Url: ( [!#$%&*-\[\]-~] | NonAscii | Escape )+;
fragment Group: '(' ( Group | ~'('+ )* ')';

fragment A: [aA];
fragment B: [bB];
fragment C: [cC];
fragment D: [dD];
fragment E: [eE];
fragment F: [fF];
fragment G: [gG];
fragment H: [hH];
fragment I: [iI];
fragment K: [kK];
fragment L: [lL];
fragment M: [mM];
fragment N: [nN];
fragment O: [oO];
fragment P: [pP];
fragment R: [rR];
fragment S: [sS];
fragment T: [tT];
fragment U: [uU];
fragment W: [wW];
fragment X: [xX];
fragment Y: [yY];
fragment Z: [zZ];